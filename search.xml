<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>283 移动零</title>
    <url>/283-%E7%A7%BB%E5%8A%A8%E9%9B%B6.html</url>
    <content><![CDATA[<p>​    给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。</p>
<p>示例:</p>
<p>输入: [0,1,0,3,12]<br>输出: [1,3,12,0,0]<br>说明:</p>
<p>1、必须在原数组上操作，不能拷贝额外的数组。<br>2、尽量减少操作次数。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/move-zeroes" target="_blank" rel="noopener">https://leetcode-cn.com/problems/move-zeroes</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<p>解法一：这是我最开始想到的一种解法。</p>
<p>​    现在来看输入和输出，题目要求我们是将所有的零移动到后面，将所有的不为零的数字保持相对顺序的情况下将原本0的位置覆盖。所以，我们开始的时候，先去找不为零的数字，将它放到数组的前面去。具体操作过程如下</p>
<p><img src="/image-20200418121703127.png" alt="image-20200418121703127"></p>
<p>之后，我们从下标2开始去找非零数字(之前找到的下标为1，并且已经设置为零)，然后重复上述操作。</p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pos=<span class="number">0</span>;<span class="comment">/*pos用来标记找到的非零数字下标*/</span></span><br><span class="line">        <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)<span class="comment">/*外层i循环是用来确定数字放置的位置*/</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(j=pos;j&lt;nums.<span class="built_in">size</span>();j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j]!=<span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                	<span class="keyword">int</span> temp=nums[j];</span><br><span class="line">					nums[j]=<span class="number">0</span>;</span><br><span class="line">                    nums[i]=temp;</span><br><span class="line">                    </span><br><span class="line">                    pos=j+<span class="number">1</span>;<span class="comment">/*将查找位置向下移动*/</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(j&gt;nums.<span class="built_in">size</span>()<span class="number">-1</span>)<span class="comment">/*如果我们查找的位置大于数组长度，说明已经结束*/</span></span><br><span class="line">            	<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>该算法在leetcode上运行结果如下：</p>
<p>​    <img src="/image-20200418130041294.png" alt="image-20200418130041294"></p>
<p>解法二：</p>
<p>​    在解法一中，我们是一个位置一个位置去填充，那么我们能不能知道每个数字具体要移动的长度呢？这样我们就可以直接进行移动。观察给出的示例</p>
<p>​    输入: [0,1,0,3,12]<br>​    输出: [1,3,12,0,0]</p>
<p>我们会发现，1的下标从1变成0,而3和12的下标都减少了2,而他们对应减少的数字，和他们之前零的个数有关。比如：</p>
<p>​    输入:[0,0,0,0,1]</p>
<p>我们需要做的就是将1移动到最前面，下标由4变成0，而1前面零的个数正好是4。所以，我们只要记录下当前零的个数，在遇到非零数字的时候，我们进行交换。</p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> range=<span class="number">0</span>;<span class="comment">/*用于记录要减少的下标大小*/</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">        	<span class="keyword">if</span>(nums[i]==<span class="number">0</span>)</span><br><span class="line">        		range++;</span><br><span class="line">        	<span class="keyword">else</span></span><br><span class="line">        	&#123;</span><br><span class="line">        		<span class="keyword">int</span> temp=nums[i];</span><br><span class="line">        		nums[i]=<span class="number">0</span>;</span><br><span class="line">        		nums[i-range]=temp;<span class="comment">/*对应下标*/</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这样，算法的时间复杂度为O(n),空间复杂度为O(1);</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>连通图(定义和连通分量)</title>
    <url>/%E8%BF%9E%E9%80%9A%E5%9B%BE-%E5%AE%9A%E4%B9%89%E5%92%8C%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F.html</url>
    <content><![CDATA[<blockquote>
<p>参考文献：《大话数据结构》</p>
</blockquote>
<h2 id="1-连通图定义"><a href="#1-连通图定义" class="headerlink" title="1. 连通图定义"></a>1. 连通图定义</h2><p>首先，我们先了解什么叫连通:<br>    在无向图中，如果从顶点v1到顶点v2之间有路径(不一定直接连接，可以有中间路径)，则称v1和v2之间是连通的。</p>
<pre class="mermaid">graph LR;
 V1((V1))---V2((V2));</pre>

<pre class="mermaid">graph LR;
    V1((V1))---V3((V3))
    V3((v3))---V2((V2))</pre>

<pre><code>以上两种，我们都可以说V1和V2是连通的</code></pre><hr>
<p>所以，什么是连通图？</p>
<pre><code>在一个无向图中，任取两个顶点，它们之间都存在路径，即它们都是连通的，那么我们    称这种无向图叫做连通图。如下图所示，即一个连通图</code></pre><pre class="mermaid">graph LR;
    A((A))---B((B))
    B((B))---C((C))
    C((C))---A</pre>

<pre><code>非连通图如下图所示：</code></pre><pre class="mermaid">graph LR;
    A((A))---B((B))
    B((B))---C((C))
    C((C))---A((A))
    D((D))---F((F))</pre>

<pre><code>由于D、F与上面A、B、C没有连通，所以该图为非连通图</code></pre><hr>
<h2 id="2-连通分量"><a href="#2-连通分量" class="headerlink" title="2. 连通分量"></a>2. 连通分量</h2><blockquote>
<p>《大话数据结构》中对于连通分量的定义如下：</p>
<ol>
<li>要是子图</li>
<li>子图要是连通的</li>
<li>连通子图含有极大顶点数</li>
<li>具有极大顶点数的连通子图包含依附于这些顶点的所有边</li>
</ol>
</blockquote>
<pre><code>在这个地方，有个很困扰我的东西，那就是什么是极大顶点数和极大连通子图。比如在上面我给出的非连通图中，D、F所构成的图就是极大连通子图。该子图就被称为连通分量。
个人理解：极大的概念是相对的。==对于一个极大连通子图来说，如果我们将任何一个不在该子图中的顶点加入到这个子图中，就会导致这个子图图不再连通==</code></pre><hr>
<pre><code>对于D、F构成的子图来说，极大顶点数是2，而D、F子图包含了有关这两个点的所有边，所以D、F子图是一个极大连通子图。如果是下面这样</code></pre><pre class="mermaid">graph LR;
    A((A))---B((B))</pre>
<p>虽然它满足了子图和连通的要求，但是不符合第三点和第四点。如果此时我们将C顶点加入到该子图中</p>
<pre class="mermaid">graph LR;
    A((A))---B((B))
    B((B))---C((C))
    C((C))---A((A))</pre>



<p>我们会发现，它还能满足连通的条件，此外，即使我们没有把C顶点加入到该子图中，我们会发现，对A和B来说，都还有一条边没有加入到该子图中(A-C与B-C)，所以该子图就不满足上面所述的定义。</p>
<h2 id="3-强连通图和强连通分量"><a href="#3-强连通图和强连通分量" class="headerlink" title="3. 强连通图和强连通分量"></a>3. 强连通图和强连通分量</h2><pre><code>### 强连通图</code></pre><blockquote>
<p>引自《大话数据结构》：</p>
</blockquote>
<blockquote>
<p>在有向图G中，如果对于每一对vi,vj∈V、vi≠vj，从vi到vj和vj到vi都路径的存在，称G为强连通图</p>
</blockquote>
<pre class="mermaid">graph LR;
    A((A))-->B((B))
    B((B))-->C((C))
    C((C))-->A((A))</pre>

<h3 id="强连通分量"><a href="#强连通分量" class="headerlink" title="强连通分量"></a>强连通分量</h3><blockquote>
<p>引自《大话数据结构》：</p>
<p>有向图中的极大强连通子图称为强连通分量</p>
</blockquote>
]]></content>
      <categories>
        <category>大话数据结构</category>
      </categories>
      <tags>
        <tag>图</tag>
      </tags>
  </entry>
</search>
